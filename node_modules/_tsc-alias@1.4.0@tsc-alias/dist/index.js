"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceTscAliasPaths = void 0;
const chokidar_1 = require("chokidar");
const fs_1 = require("fs");
const globby_1 = require("globby");
const normalizePath = require("normalize-path");
const path_1 = require("path");
const helpers_1 = require("./helpers");
const utils_1 = require("./utils");
function replaceTscAliasPaths(options = {
    watch: false,
    silent: false
}) {
    return __awaiter(this, void 0, void 0, function* () {
        const output = new utils_1.Output(options.silent);
        output.info('=== tsc-alias starting ===');
        const configFile = !options.configFile
            ? (0, path_1.resolve)(process.cwd(), 'tsconfig.json')
            : !(0, path_1.isAbsolute)(options.configFile)
                ? (0, path_1.resolve)(process.cwd(), options.configFile)
                : options.configFile;
        const assert = (claim, message) => claim || output.error(message, true);
        assert((0, fs_1.existsSync)(configFile), `Invalid file path => ${configFile}`);
        let { baseUrl = './', outDir, paths } = (0, helpers_1.loadConfig)(configFile);
        if (options.outDir)
            outDir = options.outDir;
        assert(paths, 'compilerOptions.paths is not set');
        assert(outDir, 'compilerOptions.outDir is not set');
        const configDir = normalizePath((0, path_1.dirname)(configFile));
        const outPath = normalizePath((0, path_1.normalize)(configDir + '/' + outDir));
        const confDirParentFolderName = (0, path_1.basename)(configDir);
        let hasExtraModule = false;
        let configDirInOutPath = null;
        let relConfDirPathInOutPath;
        const aliases = Object.keys(paths)
            .map((alias) => {
            const _paths = paths[alias].map((path) => {
                path = path.replace(/\*$/, '').replace(/\.([mc])?ts(x)?$/, '.$1js$2');
                if ((0, path_1.isAbsolute)(path)) {
                    path = (0, path_1.relative)(configDir, path);
                }
                return path;
            });
            const path = _paths[0];
            const isExtra = null;
            const basePath = null;
            if ((0, path_1.normalize)(path).includes('..')) {
                if (!configDirInOutPath) {
                    configDirInOutPath = (0, helpers_1.getProjectDirPathInOutDir)(outPath, confDirParentFolderName);
                    if (configDirInOutPath) {
                        hasExtraModule = true;
                        const stepsbackPath = (0, path_1.relative)(configDirInOutPath, outPath);
                        const splitStepBackPath = normalizePath(stepsbackPath).split('/');
                        const nbOfStepBack = splitStepBackPath.length;
                        const splitConfDirInOutPath = configDirInOutPath.split('/');
                        let i = 1;
                        const splitRelPath = [];
                        while (i <= nbOfStepBack) {
                            splitRelPath.unshift(splitConfDirInOutPath[splitConfDirInOutPath.length - i]);
                            i++;
                        }
                        relConfDirPathInOutPath = splitRelPath.join('/');
                    }
                }
            }
            let prefix = alias.replace(/\*$/, '');
            return {
                shouldPrefixMatchWildly: alias.endsWith('*'),
                prefix,
                basePath,
                path,
                paths: _paths,
                isExtra
            };
        })
            .filter(({ prefix }) => prefix)
            .sort((alias1, alias2) => alias2.prefix.length - alias1.prefix.length);
        aliases.forEach((alias) => {
            if ((0, path_1.normalize)(alias.path).includes('..')) {
                const tempBasePath = normalizePath((0, path_1.normalize)(`${configDir}/${outDir}/${hasExtraModule && relConfDirPathInOutPath
                    ? relConfDirPathInOutPath
                    : ''}/${baseUrl}`));
                const absoluteBasePath = normalizePath((0, path_1.normalize)(`${tempBasePath}/${alias.path}`));
                if ((0, helpers_1.existsResolvedAlias)(absoluteBasePath)) {
                    alias.isExtra = false;
                    alias.basePath = tempBasePath;
                }
                else {
                    alias.isExtra = true;
                    alias.basePath = absoluteBasePath;
                }
            }
            else if (hasExtraModule) {
                alias.isExtra = false;
                alias.basePath = normalizePath((0, path_1.normalize)(`${configDir}/${outDir}/${relConfDirPathInOutPath}/${baseUrl}`));
            }
            else {
                alias.basePath = normalizePath((0, path_1.normalize)(`${configDir}/${outDir}`));
                alias.isExtra = false;
            }
        });
        const replaceImportStatement = ({ orig, file, alias }) => {
            var _a, _b;
            const requiredModule = (_b = (_a = orig.match((0, utils_1.newStringRegex)())) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.path;
            assert(typeof requiredModule == 'string', `Unexpected import statement pattern ${orig}`);
            const isAlias = alias.shouldPrefixMatchWildly
                ?
                    requiredModule.startsWith(alias.prefix) &&
                        requiredModule !== alias.prefix
                :
                    requiredModule === alias.prefix ||
                        requiredModule.startsWith(alias.prefix + '/');
            if (isAlias) {
                let absoluteAliasPath = (0, helpers_1.getAbsoluteAliasPath)(alias.basePath, alias.path);
                let relativeAliasPath = normalizePath((0, path_1.relative)((0, path_1.dirname)(file), absoluteAliasPath));
                if (!relativeAliasPath.startsWith('.')) {
                    relativeAliasPath = './' + relativeAliasPath;
                }
                const index = orig.indexOf(alias.prefix);
                const newImportScript = orig.substring(0, index) +
                    relativeAliasPath +
                    '/' +
                    orig.substring(index + alias.prefix.length);
                const modulePath = newImportScript.match((0, utils_1.newStringRegex)()).groups.path;
                return newImportScript.replace(modulePath, normalizePath(modulePath));
            }
            return orig;
        };
        const replaceAlias = (file, resolveFullPath) => __awaiter(this, void 0, void 0, function* () {
            const code = yield fs_1.promises.readFile(file, 'utf8');
            let tempCode = code;
            for (const alias of aliases) {
                const replacementParams = {
                    file,
                    alias
                };
                tempCode = (0, utils_1.replaceSourceImportPaths)(tempCode, file, (orig) => replaceImportStatement(Object.assign({ orig }, replacementParams)));
            }
            if (resolveFullPath) {
                tempCode = (0, utils_1.resolveFullImportPaths)(tempCode, file);
            }
            if (code !== tempCode) {
                yield fs_1.promises.writeFile(file, tempCode, 'utf8');
                return true;
            }
            return false;
        });
        const globPattern = [
            `${outPath}/**/*.{mjs,cjs,js,jsx,d.{mts,cts,ts,tsx}}`,
            `!${outPath}/**/node_modules`
        ];
        const files = (0, globby_1.sync)(globPattern, {
            dot: true,
            onlyFiles: true
        });
        const replaceList = yield Promise.all(files.map((file) => replaceAlias(file, options === null || options === void 0 ? void 0 : options.resolveFullPaths)));
        const replaceCount = replaceList.reduce((prev, curr) => (curr ? ++prev : prev), 0);
        output.info(`${replaceCount} files were affected!`);
        if (options.watch) {
            output.info('[Watching for file changes...]');
            const filesWatcher = (0, chokidar_1.watch)(globPattern);
            const tsconfigWatcher = (0, chokidar_1.watch)(configFile);
            const onFileChange = (file) => __awaiter(this, void 0, void 0, function* () { return replaceAlias(file, options === null || options === void 0 ? void 0 : options.resolveFullPaths); });
            filesWatcher.on('add', onFileChange);
            filesWatcher.on('change', onFileChange);
            tsconfigWatcher.on('change', (_) => {
                output.clear();
                filesWatcher.close();
                tsconfigWatcher.close();
                replaceTscAliasPaths(options);
            });
        }
    });
}
exports.replaceTscAliasPaths = replaceTscAliasPaths;
//# sourceMappingURL=index.js.map