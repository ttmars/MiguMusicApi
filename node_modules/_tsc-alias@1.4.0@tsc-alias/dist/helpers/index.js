"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAbsoluteAliasPath = exports.existsResolvedAlias = exports.getProjectDirPathInOutDir = exports.resolveTsConfigExtendsPath = exports.loadConfig = exports.mapPaths = void 0;
const mylas_1 = require("mylas");
const findNodeModulesPath = require("find-node-modules");
const fs = require("fs");
const globby_1 = require("globby");
const path_1 = require("path");
const mapPaths = (paths, mapper) => {
    const dest = {};
    Object.keys(paths).forEach((key) => {
        dest[key] = paths[key].map(mapper);
    });
    return dest;
};
exports.mapPaths = mapPaths;
const loadConfig = (file) => {
    if (!fs.existsSync(file)) {
        console.log(`\x1b[41m Error: \x1b[0m \x1b[31mFile ${file} not found\x1b[0m`);
        process.exit();
    }
    const { extends: ext, compilerOptions: { baseUrl, outDir, paths } = {
        baseUrl: undefined,
        outDir: undefined,
        paths: undefined
    } } = mylas_1.Json.loadS(file, true);
    const config = {};
    if (baseUrl)
        config.baseUrl = baseUrl;
    if (outDir)
        config.outDir = outDir;
    if (paths)
        config.paths = paths;
    if (ext) {
        return Object.assign(Object.assign({}, (ext.startsWith('.')
            ? (0, exports.loadConfig)((0, path_1.join)((0, path_1.dirname)(file), ext.endsWith('.json') ? ext : `${ext}.json`))
            : (0, exports.loadConfig)(resolveTsConfigExtendsPath(ext, file)))), config);
    }
    return config;
};
exports.loadConfig = loadConfig;
function resolveTsConfigExtendsPath(ext, file) {
    const tsConfigDir = (0, path_1.dirname)(file);
    const node_modules = findNodeModulesPath({ cwd: tsConfigDir });
    const targetPaths = node_modules.map((v) => (0, path_1.join)(tsConfigDir, v, ext));
    for (const targetPath of targetPaths) {
        if (ext.endsWith('.json')) {
            if (fs.existsSync(targetPath)) {
                return targetPath;
            }
            else {
                continue;
            }
        }
        let isDirectory = false;
        try {
            isDirectory = fs.lstatSync(targetPath).isDirectory();
        }
        catch (err) { }
        if (isDirectory) {
            return (0, path_1.join)(targetPath, 'tsconfig.json');
        }
        else {
            if (fs.existsSync(`${targetPath}.json`)) {
                return `${targetPath}.json`;
            }
        }
    }
}
exports.resolveTsConfigExtendsPath = resolveTsConfigExtendsPath;
function getProjectDirPathInOutDir(outDir, projectDir) {
    const dirs = (0, globby_1.sync)([
        `${outDir}/**/${projectDir}`,
        `!${outDir}/**/${projectDir}/**/${projectDir}`,
        `!${outDir}/**/node_modules`
    ], {
        dot: true,
        onlyDirectories: true
    });
    return dirs.reduce((prev, curr) => prev.split('/').length > curr.split('/').length ? prev : curr, dirs[0]);
}
exports.getProjectDirPathInOutDir = getProjectDirPathInOutDir;
function existsResolvedAlias(path) {
    if (fs.existsSync(path))
        return true;
    const files = (0, globby_1.sync)([`${path}.{mjs,cjs,js,jsx}`], {
        dot: true,
        onlyFiles: true
    });
    return !!files.length;
}
exports.existsResolvedAlias = existsResolvedAlias;
function getAbsoluteAliasPath(basePath, aliasPath) {
    const aliasPathParts = aliasPath
        .split('/')
        .filter((part) => !part.match(/^\.$|^\s*$/));
    let aliasPathPart = aliasPathParts.shift() || '';
    let pathExists;
    while (!(pathExists = fs.existsSync((0, path_1.join)(basePath, aliasPathPart))) &&
        aliasPathParts.length) {
        aliasPathPart = aliasPathParts.shift();
    }
    return (0, path_1.join)(basePath, pathExists ? aliasPathPart : '', aliasPathParts.join('/'));
}
exports.getAbsoluteAliasPath = getAbsoluteAliasPath;
//# sourceMappingURL=index.js.map