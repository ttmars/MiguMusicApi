{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/helpers/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Json } from 'mylas';\nimport * as findNodeModulesPath from 'find-node-modules';\nimport * as fs from 'fs';\nimport { sync } from 'globby';\nimport { dirname, join } from 'path';\n\nexport interface IRawTSConfig {\n  extends?: string;\n  compilerOptions?: ITSConfig;\n}\n\nexport interface ITSConfig {\n  baseUrl?: string;\n  outDir?: string;\n  paths?: { [key: string]: string[] };\n}\n\nexport const mapPaths = (\n  paths: { [key: string]: string[] },\n  mapper: (x: string) => string\n): { [key: string]: string[] } => {\n  const dest = {} as { [key: string]: string[] };\n  Object.keys(paths).forEach((key) => {\n    dest[key] = paths[key].map(mapper);\n  });\n  return dest;\n};\n\nexport const loadConfig = (file: string): ITSConfig => {\n  if (!fs.existsSync(file)) {\n    //           [BgRed_] Error: [Reset] [FgRed_]File ${file} not found[Reset]\n    console.log(\n      `\\x1b[41m Error: \\x1b[0m \\x1b[31mFile ${file} not found\\x1b[0m`\n    );\n    process.exit();\n  }\n  const {\n    extends: ext,\n    compilerOptions: { baseUrl, outDir, paths } = {\n      baseUrl: undefined,\n      outDir: undefined,\n      paths: undefined\n    }\n  } = Json.loadS<IRawTSConfig>(file, true);\n\n  const config: ITSConfig = {};\n  if (baseUrl) config.baseUrl = baseUrl;\n  if (outDir) config.outDir = outDir;\n  if (paths) config.paths = paths;\n\n  if (ext) {\n    return {\n      ...(ext.startsWith('.')\n        ? loadConfig(\n            join(dirname(file), ext.endsWith('.json') ? ext : `${ext}.json`)\n          )\n        : loadConfig(resolveTsConfigExtendsPath(ext, file))),\n      ...config\n    };\n  }\n\n  return config;\n};\n\nexport function resolveTsConfigExtendsPath(ext: string, file: string): string {\n  const tsConfigDir = dirname(file);\n  const node_modules: string[] = findNodeModulesPath({ cwd: tsConfigDir }); // Getting all node_modules directories.\n  const targetPaths = node_modules.map((v) => join(tsConfigDir, v, ext)); // Mapping node_modules to target paths.\n\n  // Recursively checking ancestor directories for tsconfig.\n  for (const targetPath of targetPaths) {\n    if (ext.endsWith('.json')) {\n      // Check if the file exists.\n      if (fs.existsSync(targetPath)) {\n        return targetPath;\n      } else {\n        continue; // Continue checking when ext is a file but not yet found.\n      }\n    }\n    let isDirectory = false;\n    try {\n      isDirectory = fs.lstatSync(targetPath).isDirectory();\n    } catch (err) {}\n    if (isDirectory) {\n      return join(targetPath, 'tsconfig.json');\n    } else {\n      // When target is not a file nor directory check with '.json' extension.\n      if (fs.existsSync(`${targetPath}.json`)) {\n        return `${targetPath}.json`;\n      }\n    }\n  }\n}\n\nexport function getProjectDirPathInOutDir(\n  outDir: string,\n  projectDir: string\n): string | undefined {\n  const dirs = sync(\n    [\n      `${outDir}/**/${projectDir}`,\n      `!${outDir}/**/${projectDir}/**/${projectDir}`,\n      `!${outDir}/**/node_modules`\n    ],\n    {\n      dot: true,\n      onlyDirectories: true\n    }\n  );\n\n  // Find the longest path\n  return dirs.reduce(\n    (prev, curr) =>\n      prev.split('/').length > curr.split('/').length ? prev : curr,\n    dirs[0]\n  );\n}\n\nexport function existsResolvedAlias(path: string): boolean {\n  if (fs.existsSync(path)) return true;\n\n  const files = sync([`${path}.{mjs,cjs,js,jsx}`], {\n    dot: true,\n    onlyFiles: true\n  });\n\n  return !!files.length;\n}\n\nexport function getAbsoluteAliasPath(\n  basePath: string,\n  aliasPath: string\n): string {\n  const aliasPathParts = aliasPath\n    .split('/')\n    .filter((part) => !part.match(/^\\.$|^\\s*$/));\n\n  let aliasPathPart = aliasPathParts.shift() || '';\n\n  let pathExists: boolean;\n  while (\n    !(pathExists = fs.existsSync(join(basePath, aliasPathPart))) &&\n    aliasPathParts.length\n  ) {\n    aliasPathPart = aliasPathParts.shift();\n  }\n\n  return join(\n    basePath,\n    pathExists ? aliasPathPart : '',\n    aliasPathParts.join('/')\n  );\n}\n"]}